<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Andrea Martino" />

<meta name="date" content="2018-04-06" />

<title>gmfd</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">gmfd</h1>
<h4 class="author"><em>Andrea Martino</em></h4>
<h4 class="date"><em>2018-04-06</em></h4>



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Package <strong>gmfd</strong> (Generalized Mahalanobis Functional Distance) is an R package which gathers statistical methods for both inference and clustering of functional data based on a generalization of Mahalanobis distance. The package supports both univariate and multivariate functional data.</p>
</div>
<div id="simulation-of-functional-data" class="section level1">
<h1>Simulation of functional data</h1>
Let us consider a process <span class="math inline">\(X(t) \in L^2(I)\)</span>, with <span class="math inline">\(I \in \mathbb{R}\)</span>, with mean function <span class="math inline">\(m(t) = \mathbb{E}[X(t)]\)</span> and covariance operator <span class="math inline">\(V\)</span>, i.e. V is a linear compact integral operator from <span class="math inline">\(L^2(I)\)</span> to <span class="math inline">\(L^2(I)\)</span> such that <span class="math inline">\((Va)(s) = \int_I v(s,t) a(t) dt \quad \forall a \in L^2(I)\)</span>, where <span class="math inline">\(v\)</span> is the covariance function defined as <span class="math inline">\(v = \mathbb{E}[(X(t) - m(t))(X(s)-m(s))]\)</span>. Then, denote with <span class="math inline">\(\{\rho_k, k \ge 1\}\)</span> and <span class="math inline">\(\{\theta_k, k \ge 1\}\)</span> respectively the sequences of eigenvalues and eigenfunctions of <span class="math inline">\(v\)</span>. The Karhunen-Loève expansion decomposes the process <span class="math inline">\(X(t)\)</span> in a sum of its mean <span class="math inline">\(m(t)\)</span> and the series of orthonormal functions <span class="math inline">\(\theta_k(t)\)</span>, each one multiplied by zero-mean uncorrelated random variables <span class="math inline">\(\sqrt{\rho_k} Z_k\)</span>, (<span class="math inline">\(\rho_k&gt;0, \mathbb{V}ar(Z_k) = 1)\)</span>. Then we can write
<span class="math display">\[\begin{equation*}
X(t) = m(t) + \sum_{k=1}^\infty Z_{k} \sqrt{\rho_k} \cdot \theta_k(t)
\end{equation*}\]</span>
<p>The function <code>gmfd_simulate( size, mean, covariance, rho, theta )</code> can simulate an univariate sample of functional data where <code>size</code> represents the number of elements to be generated while <code>mean</code> is the center of the distribution. The user can choose to use the argument <code>covariance</code> for the covariance of the data or alternatively the sequences of eigenvalues and eigenfunctions of the covariance matrix.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>( gmfd )

<span class="co"># Define the parameters</span>
n &lt;-<span class="st"> </span><span class="dv">50</span>
P &lt;-<span class="st"> </span><span class="dv">100</span>
K &lt;-<span class="st"> </span><span class="dv">150</span>

<span class="co"># Grid of the functional dataset</span>
t &lt;-<span class="st"> </span><span class="kw">seq</span>( <span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">length.out =</span> P )

<span class="co"># Define the means and the parameters to use in the simulation</span>
m1 &lt;-<span class="st"> </span>t<span class="op">^</span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>( <span class="dv">1</span> <span class="op">-</span><span class="st"> </span>t )

rho &lt;-<span class="st"> </span><span class="kw">rep</span>( <span class="dv">0</span>, K )
theta &lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="dv">0</span>, K, P )
<span class="cf">for</span> ( k <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>K ) {
  rho[k] &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">/</span><span class="st"> </span>( k <span class="op">+</span><span class="st"> </span><span class="dv">1</span> )<span class="op">^</span><span class="dv">2</span>
  <span class="cf">if</span> ( k<span class="op">%%</span><span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span> )
    theta[k, ] &lt;-<span class="st"> </span><span class="kw">sqrt</span>( <span class="dv">2</span> ) <span class="op">*</span><span class="st"> </span><span class="kw">sin</span>( k <span class="op">*</span><span class="st"> </span>pi <span class="op">*</span><span class="st"> </span>t )
  <span class="cf">else</span> <span class="cf">if</span> ( k<span class="op">%%</span><span class="dv">2</span> <span class="op">!=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;&amp;</span><span class="st"> </span>k <span class="op">!=</span><span class="st"> </span><span class="dv">1</span> )
    theta[k, ] &lt;-<span class="st"> </span><span class="kw">sqrt</span>( <span class="dv">2</span> ) <span class="op">*</span><span class="st"> </span><span class="kw">cos</span>( ( k <span class="op">-</span><span class="st"> </span><span class="dv">1</span> ) <span class="op">*</span><span class="st"> </span>pi <span class="op">*</span><span class="st"> </span>t )
  <span class="cf">else</span>
    theta[k, ] &lt;-<span class="st"> </span><span class="kw">rep</span>( <span class="dv">1</span>, P )
}

<span class="co"># Simulate the functional data</span>
X &lt;-<span class="st"> </span><span class="kw">gmfd_simulate</span>( <span class="dt">size =</span> n, <span class="dt">mean =</span> m1, <span class="dt">rho =</span> rho, <span class="dt">theta =</span> theta )</code></pre></div>
</div>
<div id="s3-class-fundata-for-functional-data" class="section level1">
<h1><code>S3</code> class <code>funData</code> for functional data</h1>
<p>For ease of manipulation and visualization, a <code>S3</code> class for both univariate and multivariate functional data has been created. A <code>funData</code> object represents a functional data and it is defined by the function <code>funData( grid, F )</code> where <code>grid</code> is the grid of evenly spaced points over which the functional data is defined and <code>F</code> is a matrix (if it is a univariate functional data) or a list (if it is a multivariate functional data). A functional data as it has been just described can be then represented by using the function <code>plot.funData</code> which takes as argument all the usual customisable graphical parameters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create a functional data object</span>
FD1 &lt;-<span class="st"> </span><span class="kw">funData</span>( t, X )

<span class="co"># Plot the funData object</span>
<span class="kw">plot</span>( FD1, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span> , <span class="dt">xlab =</span> <span class="st">&quot;grid&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;data&quot;</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
</div>
<div id="generalized-mahalanobis-distance" class="section level1">
<h1>Generalized Mahalanobis Distance</h1>
Let us consider a <span class="math inline">\(J\)</span>-dimensional sample of <span class="math inline">\(n\)</span> realizations <span class="math inline">\(\mathbf{X}_1(t), ...,\mathbf{X}_n(t)\)</span> of a stochastic process in <span class="math inline">\((L^2(I))^J\)</span>, with <span class="math inline">\(J\geq 1\)</span>. Let <span class="math inline">\(\bar{\mathbf{X}}_n(t) = n^{-1}(\mathbf{X}_1(t) + \ldots + \mathbf{X}_n(t))\)</span> be the empirical mean. The estimated covariance function is defined as follows:
<span class="math display">\[\begin{equation}
\label{hat_v}
\hat{v}(s,t) := \frac{1}{n-1} \sum_{i=1}^n \big(\mathbf{X}_i(s) - \bar{\mathbf{X}}_n(s)\big)\big(\mathbf{X}_i(t) - \bar{\mathbf{X}}_n(t)\big)^\top,
\end{equation}\]</span>
from which we can compute the sequences of its eigenfunctions <span class="math inline">\(\{\hat{\boldsymbol{\varphi}}_{k}=(\hat{\varphi}_k^{(1)},..., \hat{\varphi}_k^{(J)})^\top,\, k\geq 1\}\)</span> and the associated eigenvalues <span class="math inline">\(\{\hat{\lambda}_k;\, k \geq 1\}\)</span>. Since in this case the covariance function is computed using <span class="math inline">\(n\)</span> curves, we have <span class="math inline">\(\hat{\lambda}_k = 0\)</span> for all <span class="math inline">\(k\geq n\)</span>, and hence the functions <span class="math inline">\(\{\hat{\boldsymbol{\varphi}}_k;\, k \geq n\}\)</span> can be arbitrary chosen such that <span class="math inline">\(\{\hat{\boldsymbol{\varphi}}_k;\, k \geq 1\}\)</span> is an orthonormal basis of <span class="math inline">\((L^2(I))^J\)</span>. The empirical version of the generalized Mahalanobis distance based on the covariance estimator <span class="math inline">\(\hat{v}\)</span> can be written as follows:
<span class="math display">\[\begin{equation}\begin{aligned}
\label{def:hat_dp}
\hat{d}^2_p(\textbf{X}_i(t),\textbf{X}_j(t)) &amp;= \sum_{k=1}^{\text{min}\{n-1,P\}} \hat{d}^2_{M,k}(\textbf{X}_i(t), \textbf{X}_j(t)) \hat{h}_k(p) \\
&amp; + \sum_{k=\text{min}\{n-1,P\}+1}^{P} p \Big( \langle \textbf{X}_i(t) - \textbf{X}_j(t), \hat{\boldsymbol{\varphi}}_k \rangle \Big)^2,
\end{aligned}
\end{equation}\]</span>
<p>where <span class="math inline">\(P\)</span> is the length of the independent variable grid, while <span class="math inline">\(\hat{d}^2_{M,k}(\cdot,\cdot)\)</span> and <span class="math inline">\(\hat{h}(p)\)</span> represent the estimates of the square of the contribution to this distance along the <span class="math inline">\(k\)</span>-th component and the regularizing function, respectively. The function <code>funDist( FD1, FD2, metric, p, lambda, phi )</code> computes the distance between two functional data <code>FD1</code> and <code>FD2</code> by using the chosen <code>metric</code>. The last three parameters are used only for the generalized Mahalanobis distance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># We estimate the eigenvalues and eigenfunctions of the covariance matrix of data</span>
lambda &lt;-<span class="st"> </span><span class="kw">eigen</span>( <span class="kw">cov</span>( FD1<span class="op">$</span>data[[<span class="dv">1</span>]] ) )<span class="op">$</span>values
phi &lt;-<span class="st"> </span><span class="kw">eigen</span>( <span class="kw">cov</span>( FD1<span class="op">$</span>data[[<span class="dv">1</span>]] ) )<span class="op">$</span>vectors

<span class="co"># Extract two curves from the samples to compute the distance between them</span>
x &lt;-<span class="st"> </span><span class="kw">funData</span>( t, FD1<span class="op">$</span>data[[<span class="dv">1</span>]][<span class="dv">1</span>, ] )
y &lt;-<span class="st"> </span><span class="kw">funData</span>( t, FD1<span class="op">$</span>data[[<span class="dv">1</span>]][<span class="dv">2</span>, ] )

distance &lt;-<span class="st"> </span><span class="kw">funDist</span>( x, y, <span class="dt">metric =</span> <span class="st">&quot;mahalanobis&quot;</span>, <span class="dt">p =</span> <span class="dv">10</span><span class="op">^</span><span class="dv">5</span>, lambda, phi )
distance</code></pre></div>
<pre><code>## [1] 2.306482</code></pre>
<p>It is also possible to compute the dissimilarity matrix of a given sample by using the function <code>gmfd_diss( FD, metric, p )</code>.</p>
</div>
<div id="inference-on-the-means-of-functional-data-two-sample-hypotesis-tests" class="section level1">
<h1>Inference on the means of functional data: two sample hypotesis tests</h1>
We want now to compare the means of two functional data samples. We simulate two samples <span class="math inline">\(\mathbf{X}_1(t), ...,\mathbf{X}_{n_1}(t)\)</span> and <span class="math inline">\(\mathbf{Y}_{n_2}(t), ...,\mathbf{Y}_{n_2}(t)\)</span> and consider the following asymptotic hypotesis test:
<span class="math display">\[\begin{equation}
H_0 : m_{1} = m_{2} \qquad \text{vs} \qquad H_1: m_{1} \neq m_{2}.
\end{equation}\]</span>
<p>where <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> are the real means of the two simulated samples. We can infer on the means of the two samples by using the function <code>gmfd_test(FD1, FD2, conf.level, stat_test, p)</code> where we have the two samples <code>FD1</code> and <code>FD2</code>, the confidence level for the test <code>conf.level</code>, a string to choose the test statistic to use <code>stat_test</code> and the parameter of the regularizing function <code>p</code>. The function then returns the value of the test statistics, the value of the quantile and the p-value for the test.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Simulate another functional sample</span>
s &lt;-<span class="st"> </span><span class="dv">0</span>
<span class="cf">for</span> ( k <span class="cf">in</span> <span class="dv">4</span><span class="op">:</span>K ) {
  s &lt;-<span class="st"> </span>s <span class="op">+</span><span class="st"> </span><span class="kw">sqrt</span>( rho[k] ) <span class="op">*</span><span class="st"> </span>theta[k, ]
}

m2 &lt;-<span class="st"> </span>m1 <span class="op">+</span><span class="st"> </span>s
Y &lt;-<span class="st"> </span><span class="kw">gmfd_simulate</span>( n, m2, <span class="dt">rho =</span> rho, <span class="dt">theta =</span> theta )
FD2 &lt;-<span class="st"> </span><span class="kw">funData</span>( t, Y )

test_output &lt;-<span class="st"> </span><span class="kw">gmfd_test</span>(FD1, FD2, <span class="dt">conf.level =</span> <span class="fl">0.95</span>, <span class="dt">stat_test =</span> <span class="st">&quot;mahalanobis&quot;</span>, <span class="dt">p =</span> <span class="dv">10</span><span class="op">^</span><span class="dv">5</span>)
test_output</code></pre></div>
<pre><code>## $T0
## [1] 74.00768
## 
## $quantile
## [1] 12.52993
## 
## $pval
## [1] 0</code></pre>
</div>
<div id="clustering-the-k-means-algorithm" class="section level1">
<h1>Clustering: the k-means algorithm</h1>
<p>The functional <span class="math inline">\(k\)</span>-means clustering algorithm is an iterative procedure, alternating a step of cluster assignment, where all the curves are assigned to a cluster, and a step of centroid calculation, where a relevant functional representative (the centroid) for each cluster is identified. More precisely, the algorithm is initialized by fixing the number <span class="math inline">\(k\)</span> of clusters and by randomly selecting a set of <span class="math inline">\(k\)</span> initial centroids <span class="math inline">\(\{\boldsymbol{\chi}_1^{(0)}(t), \ldots , \boldsymbol{\chi}_k^{(0)}(t)\}\)</span> among the curves of the dataset. Given this initial choice, the algorithm iteratively repeats the two basic steps mentioned above. Formally, at the <span class="math inline">\(m^{th}\)</span> iteration of the algorithm, <span class="math inline">\(m\geq 1\)</span>, the two following steps are performed:</p>
<ul>
<li><strong>Step 1 (cluster assignment step)</strong>: each curve is assigned to the cluster with the nearest centroid at the <span class="math inline">\((m-1)^{th}\)</span> iteration, according to the distance <span class="math inline">\(\hat{d}_p\)</span>. Formally, the <span class="math inline">\(m^{th}\)</span> cluster assignment <span class="math inline">\(C_i^{(m)}\)</span> of the <span class="math inline">\(i^{th}\)</span> statistical unit, for <span class="math inline">\(i=1,\ldots,n\)</span>, can be written as follows:
<span class="math display">\[\begin{equation}    C_i^{(m)} := \underset{l=1,\ldots,k}{\operatorname{argmin}}\:\hat{d}_p(\textbf{X}_i(t), \boldsymbol{\chi}_l^{(m-1)}(t));
\end{equation}\]</span></li>
<li><strong>Step 2 (centroid calculation step)</strong>: the computation of the centroids at the <span class="math inline">\(m^{th}\)</span> iteration is performed by solving the optimization problems: for any <span class="math inline">\(l=1,\ldots,k\)</span>,
<span class="math display">\[\begin{equation}    \boldsymbol{\chi}_l^{(m)}(t) := \underset{\boldsymbol{\chi} \in (L^2(I))^J}{\operatorname{argmin}}  \sum_{i:C_i^{(m)} = l} \hat{d}_p(\textbf{X}_i(t),\boldsymbol{\chi}(t))^2,
\end{equation}\]</span>
where <span class="math inline">\(C_i^{(m)}\)</span> is the cluster assignment of the <span class="math inline">\(i^{th}\)</span> statistical unit at the <span class="math inline">\(m^{th}\)</span> iteration. The algorithm stops when the same cluster assignments are obtained at two subsequent iterations, i.e. the set of cluster assignments <span class="math inline">\(\{C_1^{(\bar{m})},\ldots,C_n^{(\bar{m})}\}\)</span> and the set of centroids <span class="math inline">\(\{\boldsymbol{\chi}_1^{(\bar{m})}(t),\ldots, \boldsymbol{\chi}_k^{(\bar{m})}(t)\}\)</span> are considered final solutions of the algorithm if <span class="math inline">\(\bar{m}\)</span> is the minimum integer such that <span class="math inline">\(C_i^{(\bar{m}+1)} \equiv C_i^{(\bar{m})}\)</span> for all <span class="math inline">\(i=1,\ldots,n\)</span>.</li>
</ul>
<p>We apply the procedure by merging the two samples <span class="math inline">\(\mathbf{X}_1(t), ...,\mathbf{X}_{n_1}(t)\)</span> and <span class="math inline">\(\mathbf{Y}_{n_2}(t), ...,\mathbf{Y}_{n_2}(t)\)</span> previously simulated using the function <code>gmfd_kmeans( FD, n.cl , metric, p )</code> where <code>n.cl</code> is the number of cluster. It returns a vector of the clusters and a vector or a list of vectors of the centers, other than a plot of the clusters along with their empirical means.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># We estimate the eigenvalues and eigenfunctions of the covariance matrix of all merged data</span>
lambda &lt;-<span class="st"> </span><span class="kw">eigen</span>( <span class="kw">cov</span>( <span class="kw">rbind</span>( FD1<span class="op">$</span>data[[<span class="dv">1</span>]], FD2<span class="op">$</span>data[[<span class="dv">1</span>]] ) ) )<span class="op">$</span>values
phi &lt;-<span class="st"> </span><span class="kw">eigen</span>( <span class="kw">cov</span> ( <span class="kw">rbind</span>( FD1<span class="op">$</span>data[[<span class="dv">1</span>]], FD2<span class="op">$</span>data[[<span class="dv">1</span>]] ) ) )<span class="op">$</span>vectors

<span class="co"># Functional data sample containing the merged samples</span>
FD &lt;-<span class="st"> </span><span class="kw">funData</span>( t, <span class="kw">rbind</span>( X, Y ) )

kmeans_output &lt;-<span class="st"> </span><span class="kw">gmfd_kmeans</span>( FD, <span class="dt">n.cl =</span> <span class="dv">2</span>, <span class="dt">metric =</span> <span class="st">&quot;mahalanobis&quot;</span>, <span class="dt">p =</span> <span class="dv">10</span><span class="op">^</span><span class="dv">5</span> )</code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAkAAAAEgCAMAAABrWDzDAAAAclBMVEUAAAAAADoAAGYAOjoAOpAAZrYAzQA6AAA6ADo6OpA6kNtmAABmADpmAGZmZjpmZrZmtv+QOgCQOjqQZgCQtpCQ2/+2ZgC2Zma2/7a2/9u2//++vr7bkDrb2//b/7bb////AAD/tmb/25D//7b//9v///8aD8XMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAZ0ElEQVR4nO2diZrbupFGlcRNJ/Ys1zNzO5NQmQu1G+//iiMSqA0AF7BIEZLr/+xuicRCFY6qCuDSF28yKXQ5+wBMzy0DyKSSAWRSyQAyqWQAmVQygEwqGUAmlQwgk0oGkEklA8ikkgFkUskAMqlkAJlUMoBMKhlAJpUMIJNKBpBJJQPIpJIBZFLJADKpZACZVDKATCoZQCaVDCCTSgaQSSUDyKSSAWRSyQAyqWQAmVQygEwqGUAmlQwgk0pbAPr4ernrTd/5+z7NaPT3f6Zb3i9f/tC0eBuM8+es2YVey3oCA9UD9PnjEvWb6siiqb8pG1Hp5/dspO9jpgHo5/donJnPVei1rGcwUDVAxM/S12xR18uffte1oNV7+hlG56oAiFln+uuV9TqlZzBQNUC3aJuhpW/jZ/yfr+PnHJv+Rr3ev4vfxtf/+x1Yu15474N/TmpSa9hXHAgsc2/2LRzDNdSWXcjGfn+/QGsYDdjm9/RrMB6gBqB4TANHYyuzvfKd4WM/oYFqAbqbJnb48fU33mJ4MbYtAQoaKl2l4wL7sJry+N4pGFAZjBHYFu8ibyxsj7WG4mxzwT5//scPBUB364TmPn+8+YVes51f/nhGA9UCNPDN31/jx7lzHSj6lgF0f3Mb4A5VbxTVr/D1wppXTvdY8l7pXp+VGT7pN49fMdlF2th9OzukcETZZv5p3gYGtgOUWGe2V7lz6PMpDVQL0P0ARFZ3jS409jT+SgD6LW6/V02OJrpJqnnlqUPYcUVjh1/3ZsPX7P4zHAzrotDYvcxbPJbh+yM2l7IRFUDSOrO95jv9UxpoI0A38IMxz4NWr8HxiRzon3F7TDDJwmNhUZNnjexAeZnwNQ0/wT68i7SxsWRYeICAgJsPBmi213ynf0oDbQxhKUDgu28DvaFXcfDjdojO8B0a64qaiX3eZKdjmUn70E7R2LjpdnkMQDKEzfaa7/RPaaCNSfQKD5TRH0zCcsCHfsHQ8x8JkEyiZ3vNd/qnNNDmaXxsCD6RjK2RsST+fv7X754fUynEs4WPsOOWlCnZZyrEoyG4ZzgSIJg5h2n8bK/5Tv+UBtIsJA49wCdKsvtvYzk5AwhFWP+lSQazz1hpaOa3ZJKR22diksENEUIoIh82F1bqdADJhcTZXrOdz2kg7akM7OGKTFFGxtaB2AIDc9d8ZeLNp8f7znfAy6J9sIu8MSwPXfPNt0u2nq4DiFZh3vxCr9nO5zTQlpOpobNv/DP6iA2tin75P5iF/QOWZUMROh7mvWLNBHh2LgjLFEM8dZE1Fp3ziD2Ff9j8fkm/YkqA5MnU2V7Tnc9poKMv51h93qfpLp5bhxrIAHp9GUCnd/HcMoBO7+K59dQAmV5cBpBJJQPIpJIBZFLJADKpZACZVDKATCoZQCaVDCCTSgaQSSUDyKSSAWRSyQAyqWQAmVQygEwqGUAmlQwgk0oGkEklA8ikkgFkUskAMqlkAJlUMoBMKhlAJpUMIJNKBpBJJQPIpNLOAF2eRvt+7l/XPnsDtG9zx+ksgM7ptl4G0IIMoHk9GKB6z3e2HnugL2wf80AndNuf03mNDKAFnRvC2ifIAFqQ5UDzMoAWdHII69v1QeHIDKAFWQ40JQNolU4HqFmIDKBVOh2gdgkaZQAt6HyAWpV5oFU6F6CWCTKAVul8gFqFyABaJQNoSgbQKh14oLfsLySl3bYcwnoDaJWOOdD3y+Xbx9+GP7r9W7mAAfTY5o7TIQf6/uUP/x7+yODEH60DgBqOYQbQKh1xoKPf+fjrANBN/n2c5HKOXx2gj68TDvqXB2j465Of//LLHuiA3nfSkSEM/6DsJftLrFuaO1WHHOgVrBJQmuy279tF6NAc6Bb+wKt5oCldw/TrdpkyEHqgPWPYrjAem0T//D645hygF75k84hu++CCet/vMvj7erODc6BhkrHogbrKRk9QCwA1eVb+8Gn89fJtOYS1TFA4tlMB6vp9XE/UviGs0j71hvz4+pc1HqhZhs4HqOu6Pa9J7HdF6H5ww68jp/GfPyZzRANoQTlAu4y9opG06gMAWm6uWXgGNQFQhzHshByoT9/wDQbQks4HaHRBe03B1iEoAmZWgR9JGwA1HMO6FwKop5+TTTF0+sIaeOYH2wGoWYLGn+cDBDOxffKXGYB6yLP7rGwhl28EoEbhGdQOQL364vq++I68SqAUGILNuD8uRonw1ghA+7a6pxoJYYEgVRiL1QkH3EGpcU/vs5VLqCEwbgWg4SjapOgUgNLLOSAJ0gEkshrGUXQ7cM6th7K9TxYwSyGwGYBaJagFDxQAig6kbkUxCVroPSAa9ehVeJbVIzv5lUhJ9y0B5HeiaFcQWwFoXEusv7JM8MHS8Mhi9Dwyu4HtEiARwVBdKwDhqOtHv9uVoCYA6jGNlgnuHEtJ7IHJVWSwp1fMq6FfisD1HqnzGN5YmzT/OR+gfUd9e1UX/2NT7QDkcfxRSwAxhxU9DQKEbGBuBJeMoHsKTeRZEEu1mwHo4TP5rvgysOMYQs0A1NEoFxeHvRzrHr0OpccAIGXjPXMstCPiQ7BOY9sSQDH0KEDq6OdMKx38S8syx9MaQBjDPISdIIwuvXzvKVhFRMDbQOyipiDhYfkQhkvcDitEaWR8MYA6QQZQ0OGvLqRbsPLdyXxpdDw8fPkNBtpXBYBYLkKLOhR8YDtC1SNAAAatFxIrfK+XDEFG5LEiOby+KYAIom3qnBh9Bw5GkNN5/k/mXoEg0UhLAHkcVQmQXNnxmBiTB0FHxFuQAHFq0Elx5nD2xuJof5YHShbKgJ0wwBuzIdfxZYDu/tYFeBxb6gYfB/Sw87gOUh/64b1vKIR1fepDaJYtToFSCcacWOTh/sXzguRlepr7Y2jrMQHDuWBLHiiMv6RnhiUH+138NzYQuBl2uPFdXKIUvobBKgAqZkGNAETnw2BkITPxmLd44TSIC8YGpjN9L8rGXph3kYQRS96LEi0BBKGGUyQBEtElDn0HrmPwNSM0bvg9eCTnmbfpOvQ5HQN22JjFLZY8tRLCxEqQdB2UNOfJS/aaGPMTRaBD2Q9O4GQ7Gg90i0Fo8nLV9c2JHKh4cZBL49qY71BJB9Fr5MmFlyNAzNlEOCNFwT2NsEUf1mES7aI76hQA7WgfAIjNr8VMKRSK/ijHLIWDKCi21k8oIor+bPy3FaCf3y9v4dXnj6m7Ttc3RykQRpywPfxyYUA7nCO5gR/uVWhJ3QU0YgzrxrdDPhRhuG8JdeHtANAAXGhreO2gv9DMNoD2tQ8mQb440uBUMGuZ5CD3LUXavE9+JQVZqNwI0M9/5zaR7zYYiDkgB1Ns1415cEhyHMtUhjEf/YWLEI2YOEjAnQdmKDGHt66LuVHc7rBk6AEjYiR2M0Dr7LP61u8+DlU+1sQMhDDpcmTWXVR5c9EleZ5khSbbyoGS9MQFXxE9zjio44xqjD3OuRB9xtIOGYpRqUOyxlYcOTgCKIAXfgS+XMikXPjfOXRsx+RAnz+muMmezoHzsNnx9+mLoutY4ocya3rPvRtPzLcD9PPfwlO1bgoHLU6m8jjmwX0M0cVBkAq+KPiRwEbImGGuFTMbB3WBNHBCEKeAtLh/iI1jFHNjbyOLYxhzLtatMVCVfT5/vK2xD0aLOYA89zbsbQZRoZFJvHoxcRMtINZ19skAuu4AkOPwwJgzjzFSBPEpjLAb82gXHciIgosRaVYOWuoiSWOd6JVCgz7kSWPSpQdo3j7Tj1Xg9ulhrCbHvgDINCgrNdMAIbQVoHdyshMPJqlpzs2MuocIBREHHIgLIa4T4QrCzhQ6jNAQpMgRhZwLKHTce9UY6Aj7hFEbj3xybFmM2YbOtlp6D6QTeiCBEBu96DKcdBXAVofuh3GQAsh3RyeGOROjK5IZJmJdyK5CC1UGOsI+NFjkhKbGW+14kqaSyJhqO0D7qOCBHPvt+eYxxHgvhh8KeyrLNqVtYh2Ja/zlIOnGiBiO64jPXWcfGqyOrUdPjHpxqr8w1YrNLmfpcrtvZRofcxnuNgq5jKMo5FMMXPK7IIcUuY5YckmB0EnMrsKWOgMdYR/xhZ9LhGYXAYvKzARbZnphbdZ/wQ5ZSHTOlQkQCU0cTp43Qw0nUWBZjZPbaKcTBTuiKnTjHL6sM9AR9kkGfHlsFxQaydjJtYAPXCRQY59DTmU4hxiko585Jpm9UNkuhS8EoaJdiA54x9sJZ/KJtzoDHWGffPBpCLfhk5GyliCftbUZoF1EHghzD45Gl0/MHXMWkA6zKjI1knVyipI8umPU4gFtBWhH+4jVYBjYyjkXrUbOIgJbphFK21MD9PfZhbLZhXoBUJe6DMdW+8Sog/9wtG6Y4OJp4s/gEkUK/0VQRJ+kBWjOPovKPJBPJmPz4yvBYNT4yTb42TTqaYrSrQD9/E94//F1JsJfYRHkNrUawnMg57p8DSeMo6eBTidQcXYmFx/zKJfsZRlO5q0wv4416wxUY59l8ZVoNmhduFN16rKMQc7xveIjQoF7kRk2eFcZXPBmM0Df458HeZ/LED9/IDbzD9L2qQPyxZxGjnAJlqlNlNCkgTLL3rNsXhzoSq2zzwolHohP6KeH/Q5GSAoAFG4JAMc5VqbYiEOEsDCV9soQdo9Nb8PXC+YaRbE/ITL/KH/IgfjUCGlBD5JsTl0RpyKWiXvIPcFaDwYtOQuTHhAWuusMVGGfFUIPVEhep0eeCfmJeV1BGXmiCfieseKs0maAhqj0p/+Y/jNFo1Z7IEqi85nXxAzdMRocWxhCMMb0NyRDDrOieFUHLEVyCF2XLYiH7cnnXqsV9lkhbh8WcDCTnqeHCCixg6VLtZYbAIAqQzwVDF+yWV1hDruYA8VpM0tI2OyLrsZgk2vBUQfw0TeGUmGHUytPTggaif8wi/ZpiNwK0Br7TEp6aDZmfO04ftCeQhWWC5tw8Dviq0dwJonLsEJbpKUDQK7KPljwOnzDlgI8XDI14X8YQOPXX8zCfBqm2KhjkOJEeXJLbA7VIUrOMW9GMzkHXizNtKEF+bnXapV9FiU8UDp08FUZCUlcA6dsfsqWQBMwE2IGgfjF2NoGUFhpvf9UnWtODRSvEhMRi72FF75jC33ZpR+4nuMgaPGAlzSV7cmjpfjca7WvfcrOQqIeVZh1UeRLFeOhcG3p3hQiyR0a6JBZ2Ormxk/ukuASUSmTwq5ipAgUDQl+g+XQ4ZXkxzEvxLpMvdAmgI6ZheVBRhzphMtYJ3at6qTSFqPzq7NP1TrQ2uYCQDTcPLeFtEjghfOmuJCIhWIro9fxPMiF65wDYTGnoiuNcNG5y9XGOhAfWudoHhSHVNKyHh9feD136XQB1P7QleiVzVEEg8S4YyPqIKPmK424SI0shYLhMliIXQ4vffXh5gtwUPHmDGjDgUtjaTkyWWegI+yzfL6CEbPW8xSvU12swcnsyAE1cS4sJi3O0RQMpkni8g3YEjwOMuZZFg5+xztMDmLyHXPpuMUhQHEWmK6Fez1AO9gnXwdKx7VP057lM2WFEotxzHOCoKc6+xwFEJ3OiMPewe05EZrgT8jlsFMOPl5C6MJtOzg7wMqxbbwjaIAiLBTBNT/4SrAz1jzkc9fZZxUIPNEtXR6/DMzM1feFTsARVdrnOIAwlYZfdK0z3lOKd3cFLmCoHdxPRveBObpXvmMhcsRh/BHvKQws+nDbYnBHMXfyMPc/4nPX2Wf1lRsyeslaghbfp15tLvXJNvFAxg909Sfa2UCOsIFVaQeTKD6P98QTPHsjoBTu/QHHM7bZhQDnw42tzgOmYaePd+7ENDzcPxgXATz2GZzUEZ97raDbMFIVQ7xYZi7/Wa7PSJUHuvoT7Wyg+IANB89YwcVnFrYwevkOIpSHByzAKfngjBw8VAHvHPORUOito0dQxcvnA398QSCy2QBAcOJ9iZY8StGp+gUnVvBGwlvNVa2yz0EeyAM+6CocnpOn5yHEk1t4W2mcjANIHbSB9Hgf71OOLx3rGgAKCbgPM3029WPLrPt/7lF1tzaXRtvn/JQSGSrvC6DECVmpo6RgOcmus88xANHzMOAnvHXxRj8fmIiPZAnTsvj8lfggF+IleepY6aXY5uAm+M7DmgGtDokD3VmTtzajYrdTAysHWfCQDTV/dCbzMUUYvSiM5PhSHK20z5EhDF44SnZxgt5FDxSH18d0iNXxHl0Ye1Idh8blBEFOFDnC2Vp4PJVzxwK09tZmLway5AVmwZKv5QVo5USayvl0X+6F6uxzGEAo8CbxtvgASdfh8w4BnDDb8vG5Gqw6+TJf9jpZh/BsIXi6WcjQwxFMH+geqrm1uTDspfxnGa64LuCzsvIRrXK/Z0WS1qrsczxAHuKQl8+Z6uDJY+nzg1JGXPJ7UfioIerbeQ83Ms4d6FFKn86RBicZhQrjmrkQ+QjoPCOn6OR7ekjZGk9XaZ9HAEQZDScIHjwFz9GIZYW/ofo+3yw3ZTtZzMMA6k8CCEUeyCfriWlsyfaiixGcoPeBQgATboMn5okEvZB8k8urss8+hky+YYkYE+mj7nxcTwyLyR5m/3n99FW6QewRyRGC1D0IIHbhZiYAyOP5jKlVRZneeJha8XQZkOCwpN7Nx56SfJk/1jPttM4+DwlhTHjqIarjzwHu8kQ5qT3bdHmKhh2GBxKtPdDtWgGQiDvzcaUQyvDxiZ4wQXySm4Z87NCLOT/wV4S2zj4PA4jFMaEuKaOQKwLkYeFIeL9TASKPQa4k/ZsEOULICrkdZND7pAXvyZtAn+iFiinTMwA0sRlC1yZ+2OmwiZ6yAoPOBoj+uEBMcj0fXJ6UEGQ9FWJQwSPrPWTOLB9CgnoGUBY880l8iwBNDLKDAKbzPiwHn1wcEmogB+JJC6Qk2ZDSTg8AIXaUJ42Nxi5wC0Uw3AnVpfdKHB470BV6HEBu4l0hr67TJvROnYV5nE3FDJdfIoSzKCAqmYJ7YsX7vmeN9z3fJV9jiTQ7x2DaPEDHaQtB507jcWotfENP4UUkxCIJGgsTKZhMe/4e20yFUzcxI0vQpQNd/Yl2U0VzxdRko+qbORugRIwnDorHsaV5Okt3fJYpF6nJ+kKXIwBlKfRTAJRMu1V6MoAGcU8BiTD6JkxOeEZDOTJ3P+CsUpCSPtLtlFQBi7QOIA909SfaRSeNS73aAQiIkJkwQwhToizuUUNptlx8R5vFtI3P2pqehTWl0wFC9fS/lyQAM/MAUfHijoLA4wEtNLszgFarHYC8DCk93yr8AgW6Yv2V9EA5lu9wgOYPtCAD6PxupwafMlwsVmJoCiusMyuCVhzGoQB9fJ286MUAqu+WL+2kyQ1kzXyZMMNiZubeT+4RvZCzmzvQomoMufqa3yfQYw90/mqFCQB4hoKLzX1aSjQ053Cm2SLnRtuO8UDxsUDmgY7rtk8Ckohb/Sw+swFLNsqjVTm/OiiE/fw+PBnIADqg2xk3lMahtckyLzuNXk/LTqsONFGtId//9LsBdES3mIvAG3yZB6YKgiSMpZSIlg8eAtDwqF8D6Ohuc3eUx7VNIk4KbTwGoLv/+UsG0HyS2KJaBGgqwsRfc9P1mUaz4FVchUx15DT+88f0vSsG0OZu+4lBpjNfSs+T95J3hjoWoMUr7tpXgwAV3+SrPtXaVN8AWlB7AJW1vBJY0USFDKAFHXigt8v0A8m3dFtKo7c1USEDaEHHHOj75T5H/dsf/I9CbO12B9dTamytDKAFHXKg71/+GBfKFv8YzQrVrxlON7WhFTsbv6AjDnT0Ox9/HQC67XCuML1G/qEygBZ0DECDa/78l9/DA50sA2hBhxzoFfxOQOlR3R4hA2hBxxzoNUy/sqcEvfBKvQH0K3RbLwNoQQce6K81S90boKfRvp+baxagp9HaT3uIIZcaXdiv262trtYcQOsO4ZnsYwDtLgNIrVcyUL0MILVeyUBH6JXsYwCdoFeyjwF0gl7JPgbQCXol+xhAJ+iV7GMAnaBXsk8D5jQ9swwgk0oGkEklA8ikkgFkUskAMqlkAJlUMoBMKhlAJpUMIJNKBpBJJQPIpJIBZFJpT4DEg3HmnpKzoroPz7rYWv16uUw/h+8svaR9dgTodj++GxyjeFNffXh/qTKQqD7cYpzdX3y2XtM++wEUbkZ4f8vf1Ff3499VqDFQ0vtbZe8P0IvaZz+AwtOj4wMqxJv66sOrL/9dYyBRvUmAXtQ+OwLEn6w0/5ilxerj26oYL6u3GMJe1D77ARQCbAyz4k199dHjVhko6bA+RT1cL2qfRgEanvClMND7/Zv28XXpBtHH6kXt02YIG99sd9H1GcYD9KL2aTOJvsZnjKyP0qJ6/ff7AXpR+zQ7ja/8honqwVo13+8H6EXt0+5CYuVKq6jeYg70ovbZ81TGNaT2YZXhWp3ni+q+eqleVH+/+/fG+HlR+9jJVJNKBpBJJQPIpJIBZFLJADKpZACZVDKATCoZQCaVDCCTSgaQSSUDyKSSAWRSyQAyqWQAmVQygEwqGUAmlQwgk0oGkEklA8ikkgFkUskAMqlkAJlUMoBMKhlAJpUMIJNKBpBJJQPIpNITAHRr61F1zelc+7QP0M/vBtCcTraPAfTsMoDm9fH1UvdE7V9MZ9uneYDO/oY1L/NACzKA5mUALcgAmpcBtCADaF4G0IIMoHkZQAsygOZlAC3o5/fmHrfalE62T/sA+XdbB5rVufZ5AoBMLcsAMqlkAJlUMoBMKhlAJpUMIJNKBpBJJQPIpJIBZFLJADKpZACZVDKATCoZQCaVDCCTSgaQSSUDyKSSAWRSyQAyqWQAmVQygEwqGUAmlQwgk0oGkEklA8ik0v8DQKMWIfcTgEYAAAAASUVORK5CYII=" style="display: block; margin: auto;" /></p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
